# 抽象化の所有権に注意する

## 依存関係逆転の法則
Rober Martinが述べた抽象化の必要性についての言葉。
```
柔軟性がもっとも高いシステムは、抽象化のみに依存し、具象実装には依存しない設計である。
```

このことを一般には依存関係逆転の原則(DIP Depnedency Inversion Principle)と言います。熊野区すると、依存関係を管理するには、具象型や実装詳細ではなく抽象化に依存すべきであるということです。
この原則では継承階層については何も言及しておらず、抽象化についてのみ行っている点に注意してください。

次の場合を考えてみましょう。ATMの処理を実装するとします。ATMには様々な種類の処理があります。引出(withdrawal)、預入(deposit)、振込(transfer)などです。いずれも扱うのは現金で、処理は完遂するか、またはエラーが発生すれば中断し、全てを基に戻す必要があります。
このような動作を一般に**トランザクション**と言います。従って、Transactionという名前の抽象化を設けます。Deposit, Withdrawal, Transferは全てTransactionの派生とします。

![](/ch2/guid9/transaction1.drawio.png)
**トランザクションとUI間の強い依存関係(最初の案)**

どのトランザクションにも、顧客がUIを用い入力したデータが必要です。UIクラスには入力データを取得する様々な関数が多数あります。
3種類のトランザクションは必要に応じ、これらの関数をコールします。図では黒塗りの矢印でこの関係を表していまます。すなわり、2種類のトランザクションはUIクラスに依存しています。

この状況で何かに変更が加えられたらどうなるでしょうか？例えばVIP向けのSpeedTransferトランザクションを追加しなければならなくなったとしましょう。
UIクラスを変更し、若干の関数追加が必要になります。(例えば、requestSpeedTransferAmount()とrequestVIPNumber())すると、UIクラスに直接依存しているため、他のトランザクションも影響を受けます。

この余計な手間が発生した原因は、アーキテクチャにあります。トランザクションクラスそれぞれがUIクラスに直接依存しているため、トランザクションクラス同士が間接的に相互依存してしまうのです。
トランザクションクラスはアーキテクチャの上位にあり、UIクラスは下位ですが、上位が下位に依存してしまっています。正しくは逆方向の依存関係であるべきです。

UIクラスへの依存関係が原因で、全トランザクションクラスが間接的に相互依存している上に、アーキテクチャの上位が下位に依存しています。UIクラスの具象実装に依存しないよう、抽象化を導入する必要があります。
しかし抽象化1つでは解決できません。3種類あるトランザクションは依然として間接的に関係を持っています。3つの抽象化、トランザクション種類ごとに1つの抽象化が必要です。

![](ch2/guid9/transaction2.drawio.png)
**トランザクションとUI間の依存関係を軽減**

DepositUI、WithdrawalUI、TransferUIの3クラスの導入により、もう具象クラスに依存しておらず、3トランザクション間の依存関係を排除できました。
代わりに、トランザクションクラスが真に必要な処理のみを表現する、軽量な抽象化に依存しています。
この状態からSpeedTransferトランザクションを追加すると、同時にSpeedTransferUI抽象化も追加するため、UIクラスに変更を加えても、他のトランザクションクラスには影響しません。

しかし、ここで導入したのは依存関係のローカルな逆転です。（UIクラスと抽象化クラス内の関係を逆転させた）
アーキテクチャの観点からすると、上位から下位への依存関係がなくなっていないのです。（トランザクションクラスからUI機能への依存関係）すなわち、抽象化を単に導入するだけでは不十分で、**どこに抽象化を導入するか**が重要なのです。

下位が上位へ依存するように、3種類の抽象化を上位に配置した場合の依存関係を示します。
![](ch2/guid9/transaction3.drawio.png)
**上位での抽象化による依存関係逆転**

アーキテクチャの上位で抽象化し、上位を抽象化の所有者にすることで、DIPに真に従えます。すなわち、全ての矢印が下位から上位へ向くようになります。
これで正しいアーキテクチャとなりました。

ただし、これは単なる発想の転換では済まないレベルかもしれません。UIクラスが依存するヘッダーファイルを別のモジュールへ移動したり、異uんするインクルードぶんをガラリと再配置する必要もあるでしょう。
これは単なる発想の転換ではなく、所有権の再割り当てです。

SRPに正しく従うには上位で抽象化するしか方法はありません。
同じものに属するのはUIクラスではなく、トランザクションクラスとそれが依存するUI抽象化です。
依存関係を正しく逆転させるには、抽象化を上位に**所有させなければなりません。**

ファイル配置もアーキテクチャの中で上位・下位を表現する方法であり、上位のディレクトリに抽象化を配置することで、依存関係を逆転させることができます。

## プラグインアーキテクチャの依存関係逆転
読者がテキストエディタの開発をしているとします。
エディタの核となるEditorクラスがあります。他の開発者は、プラグインという形で新機能を追加でき、開発に参加できるような構造にしたいと考えています。

![](ch2/guid9/editor1.drawio.png)
**良くないプラグインアーキテクチャ:  上位のEditorクラスが下位のVimModePluginクラスへ依存している**

図に示したアーキテクチャは、発展性に欠けます。
Editorクラスはアーキテクチャの上位であり、主開発者の支配下にあります。一方、VimModePluginクラスはアーキテクチャの下位にあり、ファンコミニュティのものです。
ここで、EditorクラスがVimModePluginクラスに直接依存しているため、また、この構造ではファンコミュニティがインターフェースを好きに定義できるため、新規プラグインが追加される度にEditorクラスを変更しなければなりません。

Editorクラスはすべての具象プラグインクラスに依存してはいけません。Plugin基底クラスのような形で抽象化し、Editorクラスはこの抽象化に依存すべきです。
この構造を改善するために、Plugin基底クラスを導入します。

![](ch2/guid9/editor2.drawio.png)
**良くないプラグインアーキテクチャ: 上位のEditorクラスが下位のPluginクラスへ依存している**

この構造では、ローカルな依存関係逆転が行われています。EditorクラスはPlugin基底クラスに依存しており、具象プラグインクラスには依存していません。
ただし、アーキテクチャの上位であるEditorクラスが下位のPluginクラスに依存しているため、依然として依存関係逆転が不十分です。

この誤った関係をコードで表すと次のようになります。
```C++
//---<thirdparty/Plugin.h>---
class Plugin { /* ... */ }; // Define the requirements for plugins

//---<thirdparty/VimModePlugin.h>---
#include <thirdparty/Plugin.h>

class VimModePlugin : public Plugin { /* ... */ };

//---<editor_library/Editor.h>---
#include <thirdparty/VimModePlugin.h> // Wrong direction of dependencies
                                      // 誤った方向の依存関係

class Editor { /* ... */ };
```

正しいプラグインアーキテクチャを構築する唯一の方法は、上位での抽象化です。主開発者が抽象化を**支配しなければなりません**。決してファンコミュニティ（サードパーティの開発者）に抽象化を支配させてはいけません。
アーキテクチャ上のこの依存関係を解決し、Editorクラスからプラグインへの依存関係を排除します。
この構造ならば、依存関係を正しく逆転しているためDIPに従っており、また抽象化が上位に位置しているためSRPにも従っています。

![](ch2/guid9/editor3.drawio.png)
**正しいプラグインアーキテクチャ: 下位のVimModePluginクラスが上位のPluginクラスに依存している**

コード上でも、VimModePluginクラスが、ライブラリのPluginクラスに依存していることがわかります。
```C++
//---<editor_library/Plugin.h>----
class Plugin { /* ... */ }; // Define the requirements for plugins

//---<editor_library/Editor.h>---
#include <editor_library/Plugin.h> 

class Editor { /* ... */ };

//---<thirdparty/VimModePlugin.h>---
#include <editor_library/Plugin.h> // Correct direction of dependencies
                                   // 正しい方向の依存関係
class VimModePlugin : public Plugin { /* ... */ };
```
ここでも、依存関係を正しく逆転するには、上位が抽象化を所有しなければなりません。この例で言えば、Pluginクラスは一連の要件を表現し、全プラグインはこの要件に従わなければなりません。
Editorクラスは要件を定義かつ所有するのであり、プラグイン（*多分このプラグインは具体的なプラグインを指していると思う）には依存しません。様々なプラグインが要件に依存するのです。
これが依存関係の逆転です。DIPは抽象化を導入するだけではなく、その所有権をも含むのです。

## テンプレートを介した依存関係逆転
依存関係逆転はテンプレートを用いても実現できます。所有権問題も自動的に解決できます。
`std::copy_if()`アルゴリズムを例に考えてみましょう。

```C++
template<typename InputIt, typename OutputIt, typename unaryPredicate>
OutpuIt copy_if(INputIt first, InputIt last, OutpuIt d_ifrst, unaryPredicate pred);
```

`copy_if()`アルゴリズムもDIPに従っています。依存関係を逆転しているのは、`InputIt`, `OutputIt`, `UnaryPredicate`の3つのコンセプトです。このコンセプトが渡されたイテレータと述語（プレディケート）に対する要件を表現します。
コール側はこの要件に従わなければなりません。
コンセプトにより要件を指定する、すなわちコンセプトを所有することにより、`std::copy_if()`は他のコードが地震に依存し、かつ自身は他のコードに依存しないようにします。
依存関係を下の図で示します。
コンテナも述語も、対応するアルゴリズムが表現する要件に依存しています。標準ライブラリ内のアーキテクチャを考えれば、`std::copy_if()`は上位に位置し、コンテナと述語は下位に位置します（関数オブジェクト、ラムダなども同様）。

![](ch2/guid9/copy_if.drawio.png)
**STLアルゴリズムの依存関係**

## オーバーロードセットを介した依存関係逆転
依存関係を逆転する方法は継承階層とコンセプトだけでありません。抽象化であればどの種類でも可能です。オーバーロードセットも用いてもDIPに従うようにできるます。
オーバーロードセットも抽象化であり、意味的な要件や期待する内容を表現するものです。
残念ながら基底クラスやコンセプトのように要件を明示的には記述できませんが、アーキテクチャの上位が要件を所有する限りは、依存関係逆転を実現できます。
Widgetクラスを例に考えてみましょう。

```C++
//---<Widget.h>---
#include <utility>

template typename T>
struct Widget {
  T value;
};

template<typename T>
void swap(Widget<T>& lhs, Widget<T>& rhs) {
  using std::swap;
  swap(lhs.value, rhs.value);
}
```

上例のWidgetは未知の型Tのメンバ変数を保持します。Tが未知であっても、意味的に期待する内容を構築すれば、Widget専用のswap()関数は実装可能です。
上例の実装はT用のswap()関数が期待される内容を全て満たし、LSPに従う限り正しく動作します。

```C++
#include <Widget.h>
#include <assert>
#include <cstdlib>
#include <string>

int main() {
  Widget<std::string> w1{"Hello"};
  Widget<std::string> w2{"World"};

  swap(w1, w2);

  assert(w1.value == "World");
  assert(w2.value == "Hello");

  return EXIT_SUCCESS;
}
```
結果的にWidget用のswap()関数自身は期待される内容を満たし、派生クラスの場合と同様にオーバーロードセットに加わります。swap()オーバーロードセットの依存構造をは以下です。

![](ch2/guid9/swap.drawio.png)
**swap()オーバーロードセットの依存関係**

要件や期待される内容がアーキテクチャの上位にあり、またswap()の実装が全てその要件に依存しているため、依存関係を表す矢印は下位から上位へ向いています。依存関係を正しく逆転したのです。