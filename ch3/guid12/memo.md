# デザインパターンを誤解してはいけない

デザインパターンに対するいくつかの誤解が広まっています。
- デザインパターンは最終目的であり、使用すれば高品質のソフトウェアが保証される。
- デザインパターンは特定の実装に基づく、特定の言語でのみ使用するイディオムである。
- デザインパターンはオブジェクト指向プログラミングや動的多態性でなければ使えない。
- デザインパターンは古く、時代遅れの代物である。

以下とガイドライン13で、これらの誤解を解消します。

## デザインパターンは最終目的ではない
デザインパターンは決して**最終目的**ではありません。最終目的に辿り着くための手段です。解の一部になることはあるかもしれませんが、決して最終目的ではありません。
デザインパターンは複雑度を減少こそすれど、逆に増加させるなどあってはなりません。コードは単により簡潔に、より生産的に、さらに保守性も高まるべきです。
デザインパターンとは依存関係問題を解決し、より良い構造を築くべきために使われるべきです。
デザインパターンを用いた結果、コードが複雑化し、他の開発者にとって問題になってしまうようであれば、解として不適切であることは明らかです。

## デザインパターンは実装詳細に関するものではない
デザインパターンの誤解の中で最もおおいのものは、特定の実装を基にしていというものです。
多くのデザインパターン、中でもGoFパターンはオブジェクト指向プログラミングの例として取り上げられることが多いため、この誤解が容易に広まってしまうのです。

デザインパターンが実装詳細、それに特定の言語機能やC++標準に関するものではないことを示すのも、同じくらい容易です。
同じデザインパターンに対する異なる実装例をみてみましょう。

指定された図形を描画したいとします。サンプルコードでは円を描きますが、もちろん四角形でも三角形でも構いません。描画するのは`Circle`クラスの`draw()`メンバ関数です。
```C++
class Circle {
  public:
    void draw(/* ... */); // Inplemented in terms of some graphics library
};
```

ここで`draw()`の実装が必要になるのは明白です。特に考えがなければ、`OpenGL`や`DirectX`、`Metal`、`Vulcan`その他の一般的なグラフィックライブラリを利用するでしょう。
しかし、`Circle`クラス自身が`draw()`の実装を持つのは設計上の大きな欠陥になるでしょう。`draw()`を直接実装してしまっては、グラフィックライブラリとの密接な関係性が生まれてしまいます。この関係には欠点があります。
- `Circle`を使用するとほぼ全ての場面で、たとえ描画は不要で座標計算をしたいだけだとしても、グラフィックライブラリが使用可能でなければならない。
- グラフィックライブラリに対するどんな変更でも、`Circle`クラスに影響を及ぼす可能性があり、結果的にコード変更、再テスト、再デプロイメント、その他も必要になる。
- 将来他のグラフィックライブラリに変更しても同様の事態となり、スムーズな移行は困難である。

上記の問題の源は１つに集約されます。
`Circle`クラスで`draw()`を直接実装すると**単一責任の原則**に反するのです。クラスを修正する理由が複雑になり、設計上のこの判断に強く縛られる状態です。
この問題に対する古典的オブジェクト指向な解は、円の描画方法を切り出し、基底クラスという形で抽象化することです。**バリエーションポイント**はStrategyパターンにより生まれる効果です。

Strategyパターンの目的は同種のアルゴリズムを定義し、それぞれをカプセル化することにあります。`DrawStratery`基底クラスの導入により、既存コードを経行する必要がなくなり、`Circle`の`draw()`の変更が容易になり、誰でも描画動作を追加実装できます。
![](/ch3/guid12/strategy.drawio.png)

外部から`Cricle`クラスの動作へ変更を加えられるのです。これを一般的に`依存オブジェクトの注入`(依存性の注入: Dependency Injection)と言います。

```C++
#include <Circle.h>
#include <OpenGLStrategy.h>
#include <cstdlib>
#include <utility>

int main() {
  // ...

  // Creating the desired drawing strategy for a circle.
  auto strategy = std::make_unique<OpenGLStrategy>(/* OpenGL0-specific parameters */);

  // Injection the strategy into the circle; the circle doen not have to know 
  // about the specific kind of strategy, but can with blissful ignorance use 
  // it via thte `DrawStrategy` abstraction.
  // `DrawStrategy`の抽象化のおかげで、Circleはstrategyの種類を意識せず使用できる。
  Circle circle(4.2, std::move(strategy));
  circle.draw(/* ... */);

  // ...
  return EXIT_SUCCESS;
}
```

上例は描画方法が変化してもそのまま使用できる、柔軟性が大幅に向上した形です。特定グラフィックライブラリに依存する部分と、他の実装詳細を分離したため、コードの可換性、拡張性が高まります。テスト目的為特殊な実装も容易に追加できます。（図の`TestStrategy`）

Strategyパターンの目的は、オブジェクト指向プログラミングに限定しません。抽象化には基底クラスという形を用いるのが簡単というだけにすぎず、テンプレートを用いても同程度に簡単に実装できます。
```C++
template<typename DrawStrategy>
class Circle {
  public:
    void draw(/* ... */);
};
``` 
上例では、円をどう描画するのかをコンパイル時に決定します。　`DrawStrategy`基底クラスを用意し、これを指すポインタから実行時に描画方式を決定するのではなく、線画の実装詳細をテンプレート引数(`DrawStrategy`)に渡す方式です。
テンプレート非位数により外部から実装詳細を与える形でも、`Circle`は依然として実装詳細に依存していない点に注目してください。
`Circle`クラスがグラフィックライブラリから分離している点は変わらないのです。（実行時決定方式と比較すると、`DrawStrategy`を変更するたびにコンパイルが必要ですが）

テンプレートベースの解はこの例の性質を根本から変えました。（基底クラスも仮想関数もなく、描画方式を実行時に決定せず、Circleの数は全体を通じて1つではなく、具象DrawStrategyにつき1つずつ増えるなど）
それでもStrategyパターンの目的を完全に実装しており、デザインパターンとは特定の実装や抽象化に限定したものではないことを示しています。

## デザインパターンはオブジェクト指向プログラミングにも動的多態性にも限定されない
Strategyパターンの例をもう1つ挙げます。標準ライブラリ`<numeric>`ヘッダにある`std::accumulate`関数テンプレートです。
```C++
std::vector<int> v{1, 2, 3, 4, 5};
auto const sum = std::accumulate(begin(v), end(v), int{0});
```

デフォルトでは、`std::accumulate()`は指定された範囲の要素を合計します。3番目の引数には合計の初期値を与えますが、`std::accumulate()`の戻り型は3番目の引数に一致するため、単に0とせずに`int{0}`と強調し、誤解の余地を排除しています。

`std::acccumulate()`の本来の能力はもっと高く、必要に応じて、合計演算を4番目の引数に指定できるのです。
たとえば、`<functional>`ヘッダにある`std::plus`,`std::multiplies`などを指定できます。
```C++
std::vector<int> v{1, 2, 3, 4, 5};
auto const sum = std::accumulate(begin(v), end(v), int{0}, std::plus<>{});
auto const product = std::accumulate(begin(v), end(v), int{1}, std::multiplies<>{});
```

第4引数を用いれば、`std::accumulate()`でどんな種類のリダクション処理でも可能です。すなわり、第4引数はリダクション処理の実装であり、処理内容を外部から与えることで、実装を変化させられます。
`std::accumulate()`は特定の1実装に依存しておらず、誰でも自分の用途に沿うようカスタマイズできるのです。これはまさにStrategyパターンの目的です。

`std::accumulate()`の例はデザインパターンが古典的なGoFパターンでも特定の実装に限定されないこと、またオブジェクト指向プログラミングにも限定されないことを示しています。多くのデザインパターンの目的は、関数型プログラミングや汎用プログラミングなど他のパラダイムでもやはり有用なことは明白です。
デザインパターンは動的多態性にも限定しません。静的多態性でも同様に機能します。そのためC++テンプレートと組み合わせても有用です。
この点をさらに強調するため、Strategyパターンの例をさらに挙げます。`std::vector`, `std::set`クラスのテンプレートの宣言を考えてみましょう。
```C++   
namespace std {
  template<class T, 
           class Allocator = std::allocator<T>>
  class vector;

  template<class Key,
           class Compare = std::less<key>,
           class Allocator = std::allocator<key>>
  class set;
} // namespace std
```
標準ライブラリのコンテナには全て(`std::array`を除きます。)、カスタムアロケータを指定できます。`std::vector`ではテンプレートの第2引数、`std::set`では第3引数にアロケータを指定できます。コンテナがメモリを割り当てる際には、全て指定したアロケータが処理をします。

アロケータをテンプレート引数から指定可能にすることで、標準ライブラリのコンテナのメモリ割り当て処理を、外部からカスタマイズする機会が生まれます。すなわち、開発者が処理をカプセル化したアルゴリズム（先の例ではメモリ割り当てアルゴリズム）として定義できるのです。同然ながら交換可能なアルゴリズムです。その結果、使用者（先の例ではコンテナ）とは独立に、様々なアルゴリズムを適用できるようになります。