# デザインパターンの目的を把握する

デザインパターンを活用するには、デザインデザインパターンとは何かをよく理解しなければなりません。
デザインパターンの特徴を挙げます。
- 名前を持つ
- 明確な目的を持つ
- 抽象化する
- 検証済みである

## デザインパターンは名前を持つ
デザインパターンにはそれぞれ名前があります。デザインパターン名を用いることで、多くを語らずとも、十分な情報量を持つ意見を交換でき、意思疎通のレベルが高まります。

## デザインパターンは目的を持つ
デザインパターンを用いれば、意図を正確に表現でき、誤解の恐れを排除できます。
この点がデザインパターンの２つ目の基礎属性「**目的**(intent)」です。
デザインパターン名は、その目的を伝えるもので、名前だけで問題点をどのように捉えているか、どのような解を考えているのかを表現できます。

デザインパターン名を挙げたからと言って、解の実装を暗黙的に示したこととは考えないでください。デザインパターンとはそういうものではなありません。
名前から相手が考えている構造、依存関係の管理方法やシステムの今後の成長見込みなどが分かるのです。
これこそ、基礎属性の「目的」です。

## デザインパターンは抽象化を導入する
デザインパターンは何らかの抽象化を用い、依存関係を軽減する方法を提供します。すなわち、ソフトウェアエンティティかんの関係性をどう管理するかという観点を、常に意識します。

Strategyパターンを例に考えてみます。

![](/ch3/guid11/strategy.drawio.png)

Strategy基底クラスを用いた抽象化を行います。この基底クラスが、Strategy使用者(アーキテクチャの上位に属するContext)を、具象Strategyの実装詳細(アーキテクチャの下位に位置するConcreteStrageyAクラスとConcreteStrategyBクラス)から分離します。
Strategyパターンはデザインパターンの性質を全て満たしています。

デザインパターンが導入する抽象化は、基底クラスという形に限定されない点に注意してください。抽象化の方法は他にもあります。テンプレートや単なる関数オーバーロードでも抽象化できます。

逆の例を挙げます。`std::make_unique()`を考えてみましょう。
```C++
namespace std {
  template<typename T, typename... Args>
  unique_ptr<T> make_unique(Args&&... args);
} // namespace std
```
C++コミュニティによく登場する**ファクトリ関数**(factory function)、`std::make_unique()`です。ファクトリ関数と聞けば、`std::make_unique()`はFactory Methodパターンなんだろうなと思ってしまうかもしれませんが、実はそうではありません。
デザインパターンは、実装は後で好きにカスタマイズできるよう、抽象化を用い分離するものです。
特にFactoryMethodパターンの目的は**カスタマイゼーションポイント**を設け、オブジェクトをインスタンス化することにあります。std::make_unique()にはそのようなかスタマイゼーションポイントはありません。
`std::make_unique()`を使えば、newにより、対象の型のインスタンスを作成し、これを指す、`std::unique_ptr`が得られます。
```C++
// This will create `Widget` by means of calling `new`
auto ptr = std::make_unique<Widget>(/* some Widget arguments */);
```

`std::make_unique()`には動作をカスタマイズする方法がないため、ソフトウェアエンティティ間の密接な関係性を削減できず、そのため、デザインパターンの目的には適いません。
しかし、`std::make_unique()`はある種の問題を解決するために用いられる解であり、パターンとして使われています。これは**実装パターン**(implementation pattern)であり、デザインパターンではありません。
実装をカプセル化するためよく利用されますが（この場合は`Widget`のインスタンス化をカプセル化しています）、何をどうインスタンス化するかを抽象化している訳ではありません。そのため、**実装詳細**(implementation detail)レベルの話で、**ソフトウェア設計**(software design)レベルの話ではありません。

抽象化は、ソフトウェアエンティティを分離し、将来の拡張や変更に耐える設計の鍵となります。`std::make_unique()`関数テンプレートに抽象化は存在せず、機能を拡張する術がないのです。（オーバーロードも特殊化も正しく行えません。）
対してFactory Methodパターンは、何をどうインスタンス化するかをカスタマイズできる、抽象化を備えています。（インスタンス化前後の動作もカスタマイズ可能）。
この抽象化のおかげで、既存コードを変更することなく、ファクトリを追加実装できます。

`std::make_unique()`は実装パターンにすぎませんが、デザインパターンはソフトウェアの独立性と拡張性を高めるのです。

## デザインパターンは検証が済んでいる
デザインパターンは長い年月をかけて検証されてきたものです。開発物件こそ違えど、同じ問題に対しよく使用された解を集めたものです。
十分な使用実績を示した解がデザインパターンになったのです。

## まとめ
- デザインパターンは独立性を高める目的を持ち、名前を持ち、かつ検証済みの解であることを理解する。
- デザインパターンは何らかの形で抽象化することを認識する。
- デザインパターンはソフトウェア設計レベルで使用するものであり、依存関係の管理を目的としていることを忘れてはならない。
- デザインパターンと実装パターンの相違を認識する。
